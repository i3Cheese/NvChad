snippet solveone
	function solve(input: string) -> string {
		let lines = input.split("\n");
		let t = int(lines[0]);
		let anses: string[] = [];
		for (let i = 0; i < t; i += 1) {
			let arg = ${1:[lines[2 * i + 1], lines[2 * i + 2]]};
			anses.push(solveone(arg));
		}
		return anses.join("\n");
	}

	function solveone(lines: string[]) -> string {
		${0}
		return "";
	}

snippet llines
    let lines = input.split("\n");

snippet 3el
	let $1_$2_$3 = lines[$4].split(" ");
	let $1 = int($1_$2_$3[0]);
	let $2 = int($1_$2_$3[1]);
	let $3 = int($1_$2_$3[2]);

snippet 2el
	let $1_$2 = lines[$3].split(" ");
	let $1 = int($1_$2[0]);
	let $2 = int($1_$2[1]);

snippet 1el
	let $1 = int(lines[$2]);

snippet readArr
	let $1 = [from x in lines[$2].split(" ") select int(x)];

snippet fmin
	function min(a: int, b: int) -> int {
		if (a < b) {
			return a;
		} else {
			return b;
		}
	}

snippet fmax
	function max(a: int, b: int) -> int {
		if (a > b) {
			return a;
		} else {
			return b;
		}
	}

snippet fabs
	function absCF(x: int) -> int {
		if (x < 0) {
			return -x;
		} else {
			return x;
		}
	}

snippet fbin_pow_mod
	let bin_pow_mod(x: int, n: int, mod: int) -> int {
		if (n == 0) {
			return 1;
		} else if (n == 1) {
			return x;
		} else if (n % 2 == 1) {
			return x * bin_pow_mod(x, n - 1, mod) % mod.
		} else {
			let t = bin_pow_mod(x, n / 2, mod);
			return t * t % mod;
		}
	}

snippet ff for i := 0..n
	for (let ${1:i} = ${2:0}; $1 < ${3:n}; $1 += 1) {
		$0
	}

snippet fr for i := n..0
	for (let ${1:i} = ${2:n - 1}; $1 >= ${3:0}; $1 -= 1) {
		$0
	}

snippet sPair pair<int, int>
	struct ${1:Pair} {
		${2:a}: int,
		${3:b}: int,
		function less(self: $1, other: $1) -> bool {
			if (self.$2 == other.$2) {
				return self.$3 < other.$3;
			} else {
				return self.$2 < self.$2;
			}
		}
	}

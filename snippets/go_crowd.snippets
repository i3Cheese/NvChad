snippet solveone
	function solve(input: string) -> string {
		let lines = input.split("\n");
		let t = int(lines[0]);
		let anses: string[] = [];
		for (let i = 0; i < t; i += 1) {
			let arg = ${1:[lines[2 * i + 1], lines[2 * i + 2]]};
			anses.push(solveone(arg));
		}
		return anses.join("\n");
	}

	function solveone(lines: string[]) -> string {
		${0}
		return "";
	}

snippet fmin
	function min(a: int, b: int) -> int {
		if (a < b) {
			return a;
		} else {
			return b;
		}
	}

snippet fmax
	function max(a: int, b: int) -> int {
		if (a > b) {
			return a;
		} else {
			return b;
		}
	}

snippet fabs
	function absCF(x: int) -> int {
		if (x < 0) {
			return -x;
		} else {
			return x;
		}
	}

snippet fbin_pow_mod
	let bin_pow_mod(x: int, n: int, mod: int) -> int {
		if (n == 0) {
			return 1;
		} else if (n == 1) {
			return x;
		} else if (n % 2 == 1) {
			return x * bin_pow_mod(x, n - 1, mod) % mod.
		} else {
			let t = bin_pow_mod(x, n / 2, mod);
			return t * t % mod;
		}
	}

snippet ff for i := 0..n
	for (let ${1:i} = ${2:0}; $1 < ${3:n}; $1 += 1) {
		$0
	}

snippet fr for i := n..0
	for (let ${1:i} = ${2:n - 1}; $1 >= ${3:0}; $1 -= 1) {
		$0
	}
